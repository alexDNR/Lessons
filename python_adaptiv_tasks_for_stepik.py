'''
Напишите программу, которая проверяет, являются ли два введённых слова анаграммами.
Программа должна вывести True в случае, если введённые слова являются анаграммами, 
и False в остальных случаях.
    Формат ввода:
Два слова, каждое на отдельной строке. 
Слово может состоять только из латинских символов произвольного регистра. 
Регистр символов не должен влиять на ответ.
    Формат вывода:
True или False.
'''
# word1 = input().lower()
# word2 = input().lower()
# print(sorted(word1) == sorted(word2))

'''
Кодирование длин серий — это базовый алгоритм сжатия данных.
В этой задаче мы реализуем одну из самых простых его вариантов.
На вход алгоритму подаётся строка, содержащая символы латинского алфавита. 
Эта строка разбивается на группы одинаковых символов, идущих подряд ("серии"). 
Каждая серия характеризуется повторяющимся символом и количеством повторений. 
Именно эта информация и записывается в код: 
сначала пишется длина серии повторяющихся символов, затем сам символ. 
У серий длиной в один символ количество повторений будем опускать.
    Например, рассмотрим строку
- aaabccccCCaB
Разобъём её на серии
- aaa b cccc CC a B
После чего закодируем серии и получим итоговую строку, 
которую и будем считать результатом работы алгоритма.
= 3ab4c2CaB
    Формат ввода:
Одна строка, содержащая произвольные символы латинского алфавита.
    Формат вывода:
Строка, содержащая закодированную последовательность.
'''
# import re
# s = input()
# for i in re.finditer(r'([A-Za-z])\1*', s):
#     count = len(i[0])
#     if count > 1:
#         print(count, end='')
#     print(i[1], end='')

# def p(prev, count):
#     if count > 1:
#         print(count, end='')
#     print(prev, end='')

# s = input()
# prev = s[0] # записываем сразу первый элемент
# count = 1 # количество повторений в ряду
# for i in s[1:]: # цикл со второго элемента
#     if i == prev: # если элемент равен предыдущему
#         count += 1 # счёт увеличиваем
#         continue
#     p(prev, count)
#     prev = i
#     count = 1
# p(prev, count)

'''
Напишите простой интерпретатор математического выражения.
На вход подаётся строка с выражением, состоящим из двух чисел, 
объединённых бинарным оператором: a operator b, 
где вместо operator могут использоваться следующие слова: 
plus, minus, multiply, divide для, соответственно, 
сложения, вычитания, умножения и целочисленного деления.
    Формат ввода:
Одна строка, содержащая выражение вида a operator b.
Оператор может быть plus, minus, multiply, divide.
    Формат вывода:
Строка, содержащая целое число - результат вычисления.
'''
# s = input().split()
# if s[1] == 'plus':
#     print(int(s[0]) + int(s[2]))
# elif s[1] == 'minus':
#     print(int(s[0]) - int(s[2]))  
# elif s[1] == 'multiply':
#     print(int(s[0]) * int(s[2])) 
# elif s[1] == 'divide':
#     print(int(s[0]) // int(s[2]))         

'''
Напишите программу, которая принимает на вход список чисел и число, 
после чего выводит все позиции, на которых это число встречается в переданном списке.
Позиции в списке нумеруются с нуля.
Если число x не найдено в списке, нужно вывести строку "None" 
(без кавычек, с большой буквы).
    Формат ввода:
На первой строке содержатся значения списка - целые числа, разделённые пробелом. 
На второй строке содержится целое число, позиции которого нужно найти.
    Формат вывода:
Одна строка, в которой содержится слово "None" или через пробел перечислены числа 
- позиции, на которых число x встречается в списке lst. 
Позиции должны быть выведены в порядке возрастания.
'''
# s = [int(i) for i in input().split()]
# n = int(input())
# if n not in s:
#     print(None)
# else:    
#     for i in range(len(s)):
#         if s[i] == n:
#             print(i, end=' ')
    
'''
Напишите программу, которая принимает на вход список целых чисел и выводит 
на экран значения, которые повторяются в нём более одного раза.
Для решения задачи может пригодиться метод sort списка.
    Формат ввода:
Одна строка с целыми числами, разделёнными пробелом.
    Формат вывода:
Строка, содержащая числа, разделённые пробелом. 
Числа не должны повторяться, порядок вывода может быть произвольным.
'''
# s = [int(i) for i in input().split()]
# s.sort()
# if len(s) == 1:
#     print(*s)
# else:    
#     for i in range(len(s)-1):
#         if s[i] == s[i+1]:
#             print(s[i], end=' ')

